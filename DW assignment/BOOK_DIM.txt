-- =============================================
-- BOOK_DIM
-- =============================================
DROP TABLE book_dim CASCADE CONSTRAINTS;
DROP SEQUENCE book_dim_seq;

CREATE TABLE book_dim
(
    book_key          NUMBER        NOT NULL,
    bookID            VARCHAR2(6)   NOT NULL,   
    copyID            VARCHAR2(6)   NOT NULL,
    bookTitle         VARCHAR2(200) NOT NULL,
    bookImei          VARCHAR2(50),
    language          VARCHAR2(50)  NOT NULL,
    author            VARCHAR2(100) NOT NULL,
    publishYear       NUMBER(4)     NOT NULL,
    bookCategory      VARCHAR2(50)  NOT NULL,
    publisherName     VARCHAR2(100) NOT NULL,
    publisherLocation VARCHAR2(100) NOT NULL,
    bookStatus        VARCHAR2(20)  NOT NULL,
    bookCondition     VARCHAR2(20)  NOT NULL,
    CONSTRAINT book_dim_pk PRIMARY KEY(book_key),
    CONSTRAINT book_dim_bookid_fk FOREIGN KEY (bookID) REFERENCES BOOK (BOOKID)
);

CREATE SEQUENCE book_dim_seq
   START WITH 1000
   INCREMENT BY 1;

-- =============================================
-- ETL: BOOK_DIM
-- =============================================
-- Use: EXEC LOAD_BOOK_DIM_INITIAL; for initial load
-- Use: EXEC LOAD_BOOK_DIM_INCREMENTAL; for subsequent loads

-- Legacy direct insert (kept for compatibility)
/*
INSERT INTO book_dim
SELECT book_dim_seq.NEXTVAL,
       bookID, copyID, clean_bookTitle, clean_bookImei, clean_language, clean_author,
       clean_publishYear, clean_category, clean_publisherName, clean_publisherLocation,
       clean_bookStatus, clean_bookCondition
FROM BOOK_STAGING_V;
*/

COMMIT;

-- =============================================
-- ETL VIEWS AND PROCEDURES
-- =============================================

-- Staging view with data scrubbing and validation
CREATE OR REPLACE VIEW BOOK_STAGING_V AS
SELECT 
    b.bookID,
    c.copyID,
    -- Data scrubbing: Clean and validate text fields
    CASE 
        WHEN TRIM(UPPER(b.bookTitle)) IS NULL OR LENGTH(TRIM(b.bookTitle)) < 2 
        THEN 'UNKNOWN TITLE'
        ELSE TRIM(UPPER(b.bookTitle))
    END as clean_bookTitle,
    -- Handle missing IMEI
    CASE 
        WHEN b.bookImei IS NULL OR TRIM(b.bookImei) = '' 
        THEN 'NO-IMEI-' || b.bookID
        ELSE TRIM(b.bookImei)
    END as clean_bookImei,
    -- Standardize language codes
    CASE 
        WHEN UPPER(TRIM(b.language)) IN ('EN', 'ENG', 'ENGLISH') THEN 'ENGLISH'
        WHEN UPPER(TRIM(b.language)) IN ('FR', 'FRA', 'FRENCH') THEN 'FRENCH'
        WHEN UPPER(TRIM(b.language)) IN ('ES', 'SPA', 'SPANISH') THEN 'SPANISH'
        WHEN TRIM(b.language) IS NULL THEN 'UNKNOWN'
        ELSE UPPER(TRIM(b.language))
    END as clean_language,
    -- Clean author names
    CASE 
        WHEN TRIM(UPPER(b.author)) IS NULL OR LENGTH(TRIM(b.author)) < 2 
        THEN 'UNKNOWN AUTHOR'
        ELSE TRIM(UPPER(b.author))
    END as clean_author,
    -- Validate publish year
    CASE 
        WHEN b.publishYear IS NULL OR b.publishYear < 1800 OR b.publishYear > EXTRACT(YEAR FROM SYSDATE)
        THEN 1900  -- Default for invalid years
        ELSE b.publishYear
    END as clean_publishYear,
    -- Standardize categories
    CASE 
        WHEN UPPER(TRIM(b.category)) IN ('FICTION', 'NOVEL') THEN 'FICTION'
        WHEN UPPER(TRIM(b.category)) IN ('NON-FICTION', 'NONFICTION') THEN 'NON-FICTION'
        WHEN UPPER(TRIM(b.category)) IN ('SCIENCE', 'SCIENCES') THEN 'SCIENCE'
        WHEN UPPER(TRIM(b.category)) IN ('HISTORY', 'HISTORICAL') THEN 'HISTORY'
        WHEN TRIM(b.category) IS NULL THEN 'GENERAL'
        ELSE UPPER(TRIM(b.category))
    END as clean_category,
    -- Clean publisher info
    CASE 
        WHEN TRIM(UPPER(b.publisherName)) IS NULL 
        THEN 'UNKNOWN PUBLISHER'
        ELSE TRIM(UPPER(b.publisherName))
    END as clean_publisherName,
    CASE 
        WHEN TRIM(UPPER(b.publisherLocation)) IS NULL 
        THEN 'UNKNOWN LOCATION'
        ELSE TRIM(UPPER(b.publisherLocation))
    END as clean_publisherLocation,
    -- Standardize status values
    CASE 
        WHEN UPPER(TRIM(c.bookStatus)) IN ('AVAILABLE', 'AVAIL') THEN 'AVAILABLE'
        WHEN UPPER(TRIM(c.bookStatus)) IN ('CHECKED OUT', 'CHECKED_OUT', 'OUT') THEN 'CHECKED_OUT'
        WHEN UPPER(TRIM(c.bookStatus)) IN ('RESERVED', 'RESERVE') THEN 'RESERVED'
        WHEN UPPER(TRIM(c.bookStatus)) IN ('DAMAGED', 'DAMAGE') THEN 'DAMAGED'
        WHEN UPPER(TRIM(c.bookStatus)) IN ('LOST', 'MISSING') THEN 'LOST'
        WHEN c.bookStatus IS NULL THEN 'AVAILABLE'
        ELSE UPPER(TRIM(c.bookStatus))
    END as clean_bookStatus,
    -- Standardize condition values
    CASE 
        WHEN UPPER(TRIM(c.bookCondition)) IN ('NEW', 'EXCELLENT') THEN 'EXCELLENT'
        WHEN UPPER(TRIM(c.bookCondition)) IN ('GOOD', 'FINE') THEN 'GOOD'
        WHEN UPPER(TRIM(c.bookCondition)) IN ('FAIR', 'AVERAGE') THEN 'FAIR'
        WHEN UPPER(TRIM(c.bookCondition)) IN ('POOR', 'BAD', 'DAMAGED') THEN 'POOR'
        WHEN c.bookCondition IS NULL THEN 'GOOD'
        ELSE UPPER(TRIM(c.bookCondition))
    END as clean_bookCondition,
    -- Data quality flags
    CASE WHEN b.bookTitle IS NULL OR LENGTH(TRIM(b.bookTitle)) < 2 THEN 'Y' ELSE 'N' END as title_cleaned,
    CASE WHEN b.bookImei IS NULL THEN 'Y' ELSE 'N' END as imei_generated,
    CASE WHEN b.publishYear IS NULL OR b.publishYear < 1800 OR b.publishYear > EXTRACT(YEAR FROM SYSDATE) THEN 'Y' ELSE 'N' END as year_defaulted
FROM BOOK b
JOIN BOOK_COPY c ON b.bookID = c.bookID
WHERE b.bookID IS NOT NULL  -- Essential data quality check
  AND c.copyID IS NOT NULL;

-- Procedure for initial BOOK_DIM loading
CREATE OR REPLACE PROCEDURE LOAD_BOOK_DIM_INITIAL AS
    v_count NUMBER;
    v_errors NUMBER := 0;
BEGIN
    -- Check if already loaded
    SELECT COUNT(*) INTO v_count FROM BOOK_DIM;
    
    IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('BOOK_DIM already contains data. Use LOAD_BOOK_DIM_INCREMENTAL for updates.');
        RETURN;
    END IF;
    
    -- Insert with comprehensive data scrubbing
    INSERT INTO BOOK_DIM (
        book_key, bookID, copyID, bookTitle, bookImei, language, author,
        publishYear, bookCategory, publisherName, publisherLocation, 
        bookStatus, bookCondition
    )
    SELECT 
        book_dim_seq.NEXTVAL,
        bookID,
        copyID,
        clean_bookTitle,
        clean_bookImei,
        clean_language,
        clean_author,
        clean_publishYear,
        clean_category,
        clean_publisherName,
        clean_publisherLocation,
        clean_bookStatus,
        clean_bookCondition
    FROM BOOK_STAGING_V;
    
    v_count := SQL%ROWCOUNT;
    
    -- Count data quality issues
    SELECT COUNT(*) INTO v_errors 
    FROM BOOK_STAGING_V 
    WHERE title_cleaned = 'Y' OR imei_generated = 'Y' OR year_defaulted = 'Y';
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('BOOK_DIM initial load completed: ' || v_count || ' records inserted.');
    DBMS_OUTPUT.PUT_LINE('Data quality corrections applied: ' || v_errors || ' records had issues corrected.');
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error in BOOK_DIM initial load: ' || SQLERRM);
        RAISE;
END;
/

-- Procedure for incremental BOOK_DIM loading
CREATE OR REPLACE PROCEDURE LOAD_BOOK_DIM_INCREMENTAL AS
    v_count NUMBER := 0;
    v_updated NUMBER := 0;
    v_errors NUMBER := 0;
BEGIN
    -- Insert new book copies
    INSERT INTO BOOK_DIM (
        book_key, bookID, copyID, bookTitle, bookImei, language, author,
        publishYear, bookCategory, publisherName, publisherLocation, 
        bookStatus, bookCondition
    )
    SELECT 
        book_dim_seq.NEXTVAL,
        s.bookID,
        s.copyID,
        s.clean_bookTitle,
        s.clean_bookImei,
        s.clean_language,
        s.clean_author,
        s.clean_publishYear,
        s.clean_category,
        s.clean_publisherName,
        s.clean_publisherLocation,
        s.clean_bookStatus,
        s.clean_bookCondition
    FROM BOOK_STAGING_V s
    WHERE NOT EXISTS (
        SELECT 1 FROM BOOK_DIM bd 
        WHERE bd.bookID = s.bookID AND bd.copyID = s.copyID
    );
    
    v_count := SQL%ROWCOUNT;
    
    -- Update existing records with cleaned data (status and condition only)
    UPDATE BOOK_DIM bd
    SET (
        bookStatus,
        bookCondition
    ) = (
        SELECT 
            s.clean_bookStatus,
            s.clean_bookCondition
        FROM BOOK_STAGING_V s
        WHERE s.bookID = bd.bookID AND s.copyID = bd.copyID
    )
    WHERE EXISTS (
        SELECT 1 FROM BOOK_STAGING_V s
        WHERE s.bookID = bd.bookID AND s.copyID = bd.copyID
        AND (bd.bookStatus != s.clean_bookStatus OR bd.bookCondition != s.clean_bookCondition)
    );
    
    v_updated := SQL%ROWCOUNT;
    
    -- Count data quality corrections in this load
    SELECT COUNT(*) INTO v_errors 
    FROM BOOK_STAGING_V s
    WHERE (s.title_cleaned = 'Y' OR s.imei_generated = 'Y' OR s.year_defaulted = 'Y')
      AND NOT EXISTS (
          SELECT 1 FROM BOOK_DIM bd 
          WHERE bd.bookID = s.bookID AND bd.copyID = s.copyID
      );
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('BOOK_DIM incremental load completed:');
    DBMS_OUTPUT.PUT_LINE('  - New records inserted: ' || v_count);
    DBMS_OUTPUT.PUT_LINE('  - Existing records updated: ' || v_updated);
    DBMS_OUTPUT.PUT_LINE('  - Data quality corrections: ' || v_errors);
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error in BOOK_DIM incremental load: ' || SQLERRM);
        RAISE;
END;
/
