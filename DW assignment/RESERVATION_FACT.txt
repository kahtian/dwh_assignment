-- =============================================
-- RESERVATION_FACT: Enhanced ETL with Views & Procedures
-- Purpose: Track all book reservations with dual date keys
-- Grain: One row per reservation detail
-- =============================================
DROP TABLE RESERVATION_FACT CASCADE CONSTRAINTS;

CREATE TABLE RESERVATION_FACT
(
    member_key               NUMBER NOT NULL,
    book_key                 NUMBER NOT NULL,
    staff_key                NUMBER NOT NULL,
    reserve_start_date_key   NUMBER NOT NULL,
    reserve_end_date_key     NUMBER NOT NULL,
    reserveID                VARCHAR2(6) NOT NULL,         
    reservationStatus        VARCHAR2(20) NOT NULL,
    reservationDuration      NUMBER,  -- calculated days between start and end
    CONSTRAINT RF_MEMBER_FK         FOREIGN KEY(member_key) REFERENCES MEMBER_DIM(member_key),
    CONSTRAINT RF_BOOK_FK           FOREIGN KEY(book_key)   REFERENCES BOOK_DIM(book_key),
    CONSTRAINT RF_STAFF_FK          FOREIGN KEY(staff_key)  REFERENCES STAFF_DIM(staff_key),
    CONSTRAINT RF_START_DATE_FK     FOREIGN KEY(reserve_start_date_key) REFERENCES DATE_DIM(date_key),
    CONSTRAINT RF_END_DATE_FK       FOREIGN KEY(reserve_end_date_key)   REFERENCES DATE_DIM(date_key),
    CONSTRAINT RF_RESERVEID_FK      FOREIGN KEY(reserveID)  REFERENCES Reservation(reserveID),
    CONSTRAINT RESERVATION_FACT_PK  PRIMARY KEY(member_key, book_key, staff_key, reserve_start_date_key, reserveID)
);

-- =============================================
-- ETL: RESERVATION_FACT (Legacy - Use procedures above for production)
-- =============================================
-- Use: EXEC LOAD_RESERVATION_FACT_INITIAL; for initial load
-- Use: EXEC LOAD_RESERVATION_FACT_INCREMENTAL; for subsequent loads

-- Legacy direct insert (kept for compatibility)
/*
INSERT INTO RESERVATION_FACT
SELECT M.member_key, B.book_key, S.staff_key,
       D_START.date_key, D_END.date_key, rs.reserveID,
       rs.clean_reserveStatus, rs.clean_reservationDuration
FROM RESERVATION_STAGING_V rs
JOIN DATE_DIM D_START ON rs.reserveStartDate = D_START.cal_date
JOIN DATE_DIM D_END ON rs.clean_reserveEndDate = D_END.cal_date
JOIN MEMBER_DIM M ON rs.memberID = M.memberID AND M.is_current_flag = '1'
JOIN BOOK_DIM B ON rs.copyID = B.copyID
JOIN STAFF_DIM S ON rs.staffID = S.staffID AND S.is_current_flag = '1';
*/

COMMIT;

-- =============================================
-- ETL VIEWS AND PROCEDURES
-- =============================================

-- Staging view with data validation and scrubbing
CREATE OR REPLACE VIEW RESERVATION_STAGING_V AS
SELECT 
    r.reserveID,
    r.reserveStartDate,
    r.reserveEndDate,
    r.memberID,
    r.staffID,
    rd.copyID,
    -- Standardize reservation status
    CASE 
        WHEN UPPER(TRIM(rd.reserveStatus)) IN ('ACTIVE', 'PENDING', 'WAITING') THEN 'ACTIVE'
        WHEN UPPER(TRIM(rd.reserveStatus)) IN ('FULFILLED', 'COMPLETED', 'PICKED_UP') THEN 'FULFILLED'
        WHEN UPPER(TRIM(rd.reserveStatus)) IN ('EXPIRED', 'TIMEOUT') THEN 'EXPIRED'
        WHEN UPPER(TRIM(rd.reserveStatus)) IN ('CANCELLED', 'CANCELED') THEN 'CANCELLED'
        WHEN rd.reserveStatus IS NULL THEN 'ACTIVE'
        ELSE UPPER(TRIM(rd.reserveStatus))
    END as clean_reserveStatus,
    -- Calculate and validate reservation duration
    CASE 
        WHEN r.reserveEndDate IS NOT NULL AND r.reserveStartDate IS NOT NULL THEN
            CASE 
                WHEN (r.reserveEndDate - r.reserveStartDate) < 0 THEN 7  -- Fix negative duration
                WHEN (r.reserveEndDate - r.reserveStartDate) > 30 THEN 30  -- Cap excessive duration
                ELSE (r.reserveEndDate - r.reserveStartDate)
            END
        WHEN r.reserveEndDate IS NULL AND r.reserveStartDate IS NOT NULL THEN
            7  -- Default 7-day reservation window
        ELSE NULL
    END as clean_reservationDuration,
    -- Handle missing end dates (apply 7-day rule)
    CASE 
        WHEN r.reserveEndDate IS NULL AND r.reserveStartDate IS NOT NULL 
        THEN r.reserveStartDate + 7
        ELSE r.reserveEndDate
    END as clean_reserveEndDate,
    -- Data quality flags
    CASE WHEN r.reserveEndDate IS NULL THEN 'Y' ELSE 'N' END as enddate_generated,
    CASE WHEN rd.reserveStatus IS NULL THEN 'Y' ELSE 'N' END as status_defaulted,
    CASE WHEN r.reserveEndDate IS NOT NULL AND (r.reserveEndDate - r.reserveStartDate) < 0 THEN 'Y' ELSE 'N' END as duration_fixed
FROM RESERVATION r
JOIN RESERVATION_DETAILS rd ON r.reserveID = rd.reserveID
WHERE r.reserveID IS NOT NULL
  AND r.reserveStartDate IS NOT NULL
  AND r.memberID IS NOT NULL
  AND r.staffID IS NOT NULL
  AND rd.copyID IS NOT NULL;

-- Procedure for initial RESERVATION_FACT loading
CREATE OR REPLACE PROCEDURE LOAD_RESERVATION_FACT_INITIAL AS
    v_count NUMBER;
    v_errors NUMBER := 0;
    v_orphaned NUMBER := 0;
BEGIN
    -- Check if already loaded
    SELECT COUNT(*) INTO v_count FROM RESERVATION_FACT;
    
    IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('RESERVATION_FACT already contains data. Use LOAD_RESERVATION_FACT_INCREMENTAL for updates.');
        RETURN;
    END IF;
    
    -- Insert with comprehensive validation
    INSERT INTO RESERVATION_FACT (
        member_key, book_key, staff_key, reserve_start_date_key, 
        reserve_end_date_key, reserveID, reservationStatus, reservationDuration
    )
    SELECT 
        M.member_key,
        B.book_key,
        S.staff_key,
        D_START.date_key AS reserve_start_date_key,
        D_END.date_key AS reserve_end_date_key,
        rs.reserveID,
        rs.clean_reserveStatus,
        rs.clean_reservationDuration
    FROM RESERVATION_STAGING_V rs
    JOIN DATE_DIM D_START ON rs.reserveStartDate = D_START.cal_date
    JOIN DATE_DIM D_END ON rs.clean_reserveEndDate = D_END.cal_date
    JOIN MEMBER_DIM M ON rs.memberID = M.memberID AND M.is_current_flag = '1'
    JOIN BOOK_DIM B ON rs.copyID = B.copyID
    JOIN STAFF_DIM S ON rs.staffID = S.staffID AND S.is_current_flag = '1';
    
    v_count := SQL%ROWCOUNT;
    
    -- Count data quality issues
    SELECT COUNT(*) INTO v_errors 
    FROM RESERVATION_STAGING_V 
    WHERE enddate_generated = 'Y' OR status_defaulted = 'Y' OR duration_fixed = 'Y';
    
    -- Check for orphaned records
    SELECT COUNT(*) INTO v_orphaned
    FROM RESERVATION_STAGING_V rs
    WHERE NOT EXISTS (SELECT 1 FROM DATE_DIM D WHERE rs.reserveStartDate = D.cal_date)
       OR NOT EXISTS (SELECT 1 FROM DATE_DIM D WHERE rs.clean_reserveEndDate = D.cal_date)
       OR NOT EXISTS (SELECT 1 FROM MEMBER_DIM M WHERE rs.memberID = M.memberID AND M.is_current_flag = '1')
       OR NOT EXISTS (SELECT 1 FROM BOOK_DIM B WHERE rs.copyID = B.copyID)
       OR NOT EXISTS (SELECT 1 FROM STAFF_DIM S WHERE rs.staffID = S.staffID AND S.is_current_flag = '1');
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('RESERVATION_FACT initial load completed: ' || v_count || ' records inserted.');
    DBMS_OUTPUT.PUT_LINE('Data quality corrections: ' || v_errors || ' records corrected.');
    IF v_orphaned > 0 THEN
        DBMS_OUTPUT.PUT_LINE('WARNING: ' || v_orphaned || ' records skipped due to missing dimension references.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error in RESERVATION_FACT initial load: ' || SQLERRM);
        RAISE;
END;
/

-- Procedure for incremental RESERVATION_FACT loading
CREATE OR REPLACE PROCEDURE LOAD_RESERVATION_FACT_INCREMENTAL(p_load_date IN DATE DEFAULT SYSDATE) AS
    v_count NUMBER := 0;
    v_updated NUMBER := 0;
    v_errors NUMBER := 0;
BEGIN
    -- Insert new reservation records
    INSERT INTO RESERVATION_FACT (
        member_key, book_key, staff_key, reserve_start_date_key, 
        reserve_end_date_key, reserveID, reservationStatus, reservationDuration
    )
    SELECT 
        M.member_key,
        B.book_key,
        S.staff_key,
        D_START.date_key AS reserve_start_date_key,
        D_END.date_key AS reserve_end_date_key,
        rs.reserveID,
        rs.clean_reserveStatus,
        rs.clean_reservationDuration
    FROM RESERVATION_STAGING_V rs
    JOIN DATE_DIM D_START ON rs.reserveStartDate = D_START.cal_date
    JOIN DATE_DIM D_END ON rs.clean_reserveEndDate = D_END.cal_date
    JOIN MEMBER_DIM M ON rs.memberID = M.memberID AND M.is_current_flag = '1'
    JOIN BOOK_DIM B ON rs.copyID = B.copyID
    JOIN STAFF_DIM S ON rs.staffID = S.staffID AND S.is_current_flag = '1'
    WHERE NOT EXISTS (SELECT 1 FROM RESERVATION_FACT rf WHERE rf.reserveID = rs.reserveID)
      AND rs.reserveStartDate >= p_load_date - 1;
    
    v_count := SQL%ROWCOUNT;
    
    -- Update existing reservations for status changes
    UPDATE RESERVATION_FACT rf
    SET reservationStatus = (
        SELECT rs.clean_reserveStatus
        FROM RESERVATION_STAGING_V rs
        WHERE rs.reserveID = rf.reserveID
    )
    WHERE EXISTS (
        SELECT 1 FROM RESERVATION_STAGING_V rs
        WHERE rs.reserveID = rf.reserveID
        AND rf.reservationStatus != rs.clean_reserveStatus
    );
    
    v_updated := SQL%ROWCOUNT;
    
    -- Count data quality issues in new records
    SELECT COUNT(*) INTO v_errors 
    FROM RESERVATION_STAGING_V rs
    WHERE (rs.enddate_generated = 'Y' OR rs.status_defaulted = 'Y' OR rs.duration_fixed = 'Y')
      AND rs.reserveStartDate >= p_load_date - 1
      AND NOT EXISTS (SELECT 1 FROM RESERVATION_FACT rf WHERE rf.reserveID = rs.reserveID);
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('RESERVATION_FACT incremental load completed:');
    DBMS_OUTPUT.PUT_LINE('  - New records inserted: ' || v_count);
    DBMS_OUTPUT.PUT_LINE('  - Existing records updated: ' || v_updated);
    DBMS_OUTPUT.PUT_LINE('  - Data quality corrections: ' || v_errors);
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error in RESERVATION_FACT incremental load: ' || SQLERRM);
        RAISE;
END;
/

-- =============================================
-- ANALYTICAL BENEFITS OF DUAL DATE KEY DESIGN
-- =============================================
-- This dual date key design enables comprehensive reservation analysis:

-- 1. Analyze reservation patterns by start date
-- SELECT D.cal_month, COUNT(*) as reservations_started
-- FROM RESERVATION_FACT RF
-- JOIN DATE_DIM D ON RF.reserve_start_date_key = D.date_key
-- GROUP BY D.cal_month;

-- 2. Analyze reservation patterns by end date  
-- SELECT D.cal_month, COUNT(*) as reservations_ended
-- FROM RESERVATION_FACT RF
-- JOIN DATE_DIM D ON RF.reserve_end_date_key = D.date_key
-- WHERE RF.reserve_end_date_key IS NOT NULL
-- GROUP BY D.cal_month;

-- 3. Find active reservations on any specific date
-- (requires additional logic or bridge table for date ranges)

-- 4. Average reservation duration analysis
-- SELECT AVG(reservationDuration) as avg_days,
--        MIN(reservationDuration) as min_days,
--        MAX(reservationDuration) as max_days
-- FROM RESERVATION_FACT
-- WHERE reservationDuration IS NOT NULL;

