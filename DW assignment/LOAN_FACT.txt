-- =============================================
-- LOAN_FACT: Enhanced ETL with Views & Procedures
-- Purpose: Track all book loans and circulation
-- Grain: One row per loan detail (book loaned)
-- =============================================


-- ===================================================================
-- SECTION 1: DATA WAREHOUSE SCHEMA DEFINITION
-- ===================================================================
-- Purpose: Define the target fact table for our ETL process.
--          This table is the final destination for the clean data.
-- -------------------------------------------------------------------

DROP TABLE LOAN_FACT CASCADE CONSTRAINTS;

CREATE TABLE LOAN_FACT
(
    member_key     NUMBER NOT NULL,
    book_key       NUMBER NOT NULL,
    staff_key      NUMBER NOT NULL,
    date_key       NUMBER NOT NULL,
    loanID         VARCHAR2(6) NOT NULL,
    loanDuration   NUMBER NOT NULL,
    overdueDays    NUMBER,
    loanStatus     VARCHAR2(20) NOT NULL,
    totalFine      NUMBER(8,2),
    fine_paid_flag NUMBER(1),
    CONSTRAINT LF_MEMBER_FK FOREIGN KEY(member_key) REFERENCES MEMBER_DIM(member_key),
    CONSTRAINT LF_BOOK_FK   FOREIGN KEY(book_key)   REFERENCES BOOK_DIM(book_key),
    CONSTRAINT LF_STAFF_FK  FOREIGN KEY(staff_key)  REFERENCES STAFF_DIM(staff_key),
    CONSTRAINT LF_DATE_FK   FOREIGN KEY(date_key)   REFERENCES DATE_DIM(date_key),
    CONSTRAINT LF_LOANID_FK FOREIGN KEY(loanID)     REFERENCES Loan(loanID),
    CONSTRAINT LOAN_FACT_PK PRIMARY KEY(member_key, book_key, staff_key, date_key, loanID)
);


-- ===================================================================
-- SECTION 2: CORE ETL TRANSFORMATION LOGIC (VIEWS)
-- ===================================================================
-- Purpose: These views form the core "Transform" (T) step of ETL.
--          They pre-process, clean, and stage the data.
--          They are used by BOTH the initial and subsequent loads.
-- -------------------------------------------------------------------

-- VIEW 1: LOAN_STAGING_V
-- This view joins raw loan tables and performs data scrubbing.
CREATE OR REPLACE VIEW LOAN_STAGING_V AS
SELECT
    l.loanID,
    l.loanDate,
    l.memberID,
    l.staffID,
    ld.copyID,
    CASE
        WHEN ld.loanDuration IS NULL OR ld.loanDuration <= 0
        THEN 14
        WHEN ld.loanDuration > 365
        THEN 365
        ELSE ld.loanDuration
    END as clean_loanDuration,
    CASE
        WHEN ld.returnDate IS NOT NULL AND ld.dueDate IS NOT NULL THEN
            CASE
                WHEN ld.returnDate > ld.dueDate THEN (ld.returnDate - ld.dueDate)
                ELSE 0
            END
        ELSE NULL
    END as clean_overdueDays,
    CASE
        WHEN UPPER(TRIM(ld.loanStatus)) IN ('ACTIVE', 'CURRENT', 'OUT') THEN 'ACTIVE'
        WHEN UPPER(TRIM(ld.loanStatus)) IN ('RETURNED', 'COMPLETE', 'COMPLETED') THEN 'RETURNED'
        WHEN UPPER(TRIM(ld.loanStatus)) IN ('OVERDUE', 'LATE') THEN 'OVERDUE'
        WHEN UPPER(TRIM(ld.loanStatus)) IN ('LOST', 'MISSING') THEN 'LOST'
        WHEN ld.loanStatus IS NULL THEN 'ACTIVE'
        ELSE UPPER(TRIM(ld.loanStatus))
    END as clean_loanStatus,
    l.loanID as fine_lookup_id,
    CASE WHEN ld.loanDuration IS NULL OR ld.loanDuration <= 0 OR ld.loanDuration > 365 THEN 'Y' ELSE 'N' END as duration_corrected,
    CASE WHEN ld.loanStatus IS NULL THEN 'Y' ELSE 'N' END as status_defaulted
FROM LOAN l
JOIN LOAN_DETAILS ld ON l.loanID = ld.loanID
WHERE l.loanID IS NOT NULL
  AND l.loanDate IS NOT NULL
  AND l.memberID IS NOT NULL
  AND l.staffID IS NOT NULL
  AND ld.copyID IS NOT NULL;

-- VIEW 2: FINE_SUMMARY_V
-- This view aggregates fine data for each loan.
CREATE OR REPLACE VIEW FINE_SUMMARY_V AS
SELECT
    loanID,
    SUM(CASE WHEN fineAmt IS NOT NULL AND fineAmt >= 0 THEN fineAmt ELSE 0 END) as totalFineAmt,
    CASE
        WHEN COUNT(fineID) > 0 AND COUNT(CASE WHEN UPPER(TRIM(fineStatus)) IN ('COMPLETED', 'PAID') THEN 1 END) = COUNT(fineID) THEN 1
        WHEN COUNT(fineID) > 0 THEN 0
        ELSE NULL
    END as paid_flag
FROM Fine
WHERE loanID IS NOT NULL
GROUP BY loanID;


-- ===================================================================
-- SECTION 3: ETL (INITIAL LOADING)
-- ===================================================================
-- Purpose: Contains the procedures and techniques for the one-time,
--          bulk load of all historical data into the empty fact table.
-- -------------------------------------------------------------------

-- PROCEDURE: LOAD_LOAN_FACT_INITIAL
CREATE OR REPLACE PROCEDURE LOAD_LOAN_FACT_INITIAL AS
    v_count NUMBER;
    v_errors NUMBER := 0;
    v_orphaned NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO v_count FROM LOAN_FACT;
    
    IF v_count > 0 THEN
        DBMS_OUTPUT.PUT_LINE('LOAN_FACT already contains data. Use LOAD_LOAN_FACT_INCREMENTAL for updates.');
        RETURN;
    END IF;
    
    INSERT INTO LOAN_FACT (
        member_key, book_key, staff_key, date_key, loanID,
        loanDuration, overdueDays, loanStatus, totalFine, fine_paid_flag
    )
    SELECT
        M.member_key,
        B.book_key,
        S.staff_key,
        D.date_key,
        ls.loanID,
        ls.clean_loanDuration,
        ls.clean_overdueDays,
        ls.clean_loanStatus,
        COALESCE(f.totalFineAmt, 0) AS totalFine,
        f.paid_flag AS fine_paid_flag
    FROM LOAN_STAGING_V ls
    JOIN DATE_DIM D ON ls.loanDate = D.cal_date
    JOIN MEMBER_DIM M ON ls.memberID = M.memberID AND M.is_current_flag = '1'
    JOIN BOOK_DIM B ON ls.copyID = B.copyID
    JOIN STAFF_DIM S ON ls.staffID = S.staffID AND S.is_current_flag = '1'
    LEFT JOIN FINE_SUMMARY_V f ON ls.fine_lookup_id = f.loanID;
    
    v_count := SQL%ROWCOUNT;
    
    SELECT COUNT(*) INTO v_errors
    FROM LOAN_STAGING_V
    WHERE duration_corrected = 'Y' OR status_defaulted = 'Y';
    
    SELECT COUNT(*) INTO v_orphaned
    FROM LOAN_STAGING_V ls
    WHERE NOT EXISTS (SELECT 1 FROM DATE_DIM D WHERE ls.loanDate = D.cal_date)
       OR NOT EXISTS (SELECT 1 FROM MEMBER_DIM M WHERE ls.memberID = M.memberID AND M.is_current_flag = '1')
       OR NOT EXISTS (SELECT 1 FROM BOOK_DIM B WHERE ls.copyID = B.copyID)
       OR NOT EXISTS (SELECT 1 FROM STAFF_DIM S WHERE ls.staffID = S.staffID AND S.is_current_flag = '1');
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('LOAN_FACT initial load completed: ' || v_count || ' records inserted.');
    DBMS_OUTPUT.PUT_LINE('Data quality corrections: ' || v_errors || ' records corrected.');
    IF v_orphaned > 0 THEN
        DBMS_OUTPUT.PUT_LINE('WARNING: ' || v_orphaned || ' records skipped due to missing dimension references.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error in LOAN_FACT initial load: ' || SQLERRM);
        RAISE;
END;
/


-- ===================================================================
-- SECTION 4: ETL (SUBSEQUENT LOADING)
-- ===================================================================
-- Purpose: Contains the procedure for ongoing, incremental updates.
-- -------------------------------------------------------------------

-- PROCEDURE: LOAD_LOAN_FACT_INCREMENTAL
CREATE OR REPLACE PROCEDURE LOAD_LOAN_FACT_INCREMENTAL(p_load_date IN DATE DEFAULT SYSDATE) AS
    v_count NUMBER := 0;
    v_updated NUMBER := 0;
    v_errors NUMBER := 0;
BEGIN
    INSERT INTO LOAN_FACT (
        member_key, book_key, staff_key, date_key, loanID,
        loanDuration, overdueDays, loanStatus, totalFine, fine_paid_flag
    )
    SELECT
        M.member_key, B.book_key, S.staff_key, D.date_key, ls.loanID,
        ls.clean_loanDuration, ls.clean_overdueDays, ls.clean_loanStatus,
        COALESCE(f.totalFineAmt, 0) AS totalFine, f.paid_flag AS fine_paid_flag
    FROM LOAN_STAGING_V ls
    JOIN DATE_DIM D ON ls.loanDate = D.cal_date
    JOIN MEMBER_DIM M ON ls.memberID = M.memberID AND M.is_current_flag = '1'
    JOIN BOOK_DIM B ON ls.copyID = B.copyID
    JOIN STAFF_DIM S ON ls.staffID = S.staffID AND S.is_current_flag = '1'
    LEFT JOIN FINE_SUMMARY_V f ON ls.fine_lookup_id = f.loanID
    WHERE NOT EXISTS (SELECT 1 FROM LOAN_FACT lf WHERE lf.loanID = ls.loanID)
      AND ls.loanDate >= p_load_date - 1;
    
    v_count := SQL%ROWCOUNT;
    
    UPDATE LOAN_FACT lf
    SET (overdueDays, loanStatus, totalFine, fine_paid_flag) =
    (
        SELECT
            ls.clean_overdueDays,
            ls.clean_loanStatus,
            COALESCE(f.totalFineAmt, 0),
            f.paid_flag
        FROM LOAN_STAGING_V ls
        LEFT JOIN FINE_SUMMARY_V f ON ls.fine_lookup_id = f.loanID
        WHERE ls.loanID = lf.loanID
    )
    WHERE EXISTS (
        SELECT 1 FROM LOAN_STAGING_V ls
        LEFT JOIN FINE_SUMMARY_V f ON ls.fine_lookup_id = f.loanID
        WHERE ls.loanID = lf.loanID
        AND (lf.loanStatus != ls.clean_loanStatus
             OR NVL(lf.overdueDays, -1) != NVL(ls.clean_overdueDays, -1)
             OR NVL(lf.totalFine, -1) != NVL(COALESCE(f.totalFineAmt, 0), -1)
             OR NVL(lf.fine_paid_flag, -1) != NVL(f.paid_flag, -1))
    );
    
    v_updated := SQL%ROWCOUNT;
    
    SELECT COUNT(*) INTO v_errors
    FROM LOAN_STAGING_V ls
    WHERE (ls.duration_corrected = 'Y' OR ls.status_defaulted = 'Y')
      AND ls.loanDate >= p_load_date - 1;
    
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('LOAN_FACT incremental load completed:');
    DBMS_OUTPUT.PUT_LINE('  - New records inserted: ' || v_count);
    DBMS_OUTPUT.PUT_LINE('  - Existing records updated: ' || v_updated);
    DBMS_OUTPUT.PUT_LINE('  - Data quality corrections: ' || v_errors);
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('Error in LOAN_FACT incremental load: ' || SQLERRM);
        RAISE;
END;
/


-- ===================================================================
-- Legacy direct insert (kept for compatibility)
-- ===================================================================

-- INSERT INTO LOAN_FACT
-- SELECT 
--     M.member_key, 
--     B.book_key, 
--     S.staff_key, 
--     D.date_key, 
--     ls.loanID, 
--     ls.clean_loanDuration, 
--     ls.clean_overdueDays, 
--     ls.clean_loanStatus, 
--     COALESCE(f.totalFineAmt, 0), 
--     f.paid_flag
-- FROM 
--     LOAN_STAGING_V ls
-- JOIN 
--     DATE_DIM D ON ls.loanDate = D.cal_date
-- JOIN 
--     MEMBER_DIM M ON ls.memberID = M.memberID AND M.is_current_flag = '1'
-- JOIN 
--     BOOK_DIM B ON ls.copyID = B.copyID
-- JOIN 
--     STAFF_DIM S ON ls.staffID = S.staffID AND S.is_current_flag = '1'
-- LEFT JOIN 
--     FINE_SUMMARY_V f ON ls.fine_lookup_id = f.loanID;

-- COMMIT;

